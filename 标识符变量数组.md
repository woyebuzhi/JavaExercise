## 标识符的使用
1.标识符：凡是自己可以起名字的地方都叫标识符。
   比如：类名、变量名、方法名、接口名、包名...

2.标识符的命名规则：--> 如果不遵守如下的规则，编译不通过！需要大家严格遵守

> 由26个英文字母大小写，0-9 ，_或 $ 组成  
> 数字不可以开头。
> 不可以使用关键字和保留字，但能包含关键字和保留字。
> Java中严格区分大小写，长度无限制。
> 标识符不能包含空格。

3. Java中的名称命名规范： --->如果不遵守如下的规范，编译可以通过！建议大家遵守

> 包名：多单词组成时所有字母都小写：xxxyyyzzz
> 类名、接口名：多单词组成时，所有单词的首字母大写：XxxYyyZzz
> 变量名、方法名：多单词组成时，第一个单词首字母小写，第二个单词开始每个单词首字母大写：xxxYyyZzz
> 常量名：所有字母都大写。多单词时每个单词用下划线连接：XXX_YYY_ZZZ

4.
注意1：在起名字时，为了提高阅读性，要尽量有意义，“见名知意”。
注意2：java采用unicode字符集，因此标识符也可以使用汉字声明，但是不建议使用。

## String类型变量的使用

1. String属于引用数据类型,翻译为：字符串
2. 声明String类型变量时，使用一对""
3. String可以和8种基本数据类型变量做运算，且运算只能是连接运算：+
4. 运算的结果仍然是String类型 

## 变量的使用

1. java定义变量的格式：数据类型 变量名 = 变量值;
2. 说明：
   ① 变量必须先声明，后使用
   ② 变量都定义在其作用域内。在作用域内，它是有效的。换句话说，出了作用域，就失效了
   ③ 同一个作用域内，不可以声明两个同名的变量

## Java定义的数据类型

一、变量按照数据类型来分：

	基本数据类型：
		整型：byte \ short \ int \ long
		浮点型：float \ double
		字符型：char
		布尔型：boolean


	引用数据类型：
		类(class)
		接口(interface)
		数组(array)

1. 整型：byte(1字节=8bit) \ short(2字节) \ int(4字节) \ long(8字节)

   > ① byte范围：-128 ~ 127
   >
   > ② 声明long型变量，必须以"l"或"L"结尾
   >
   > ③ 通常，定义整型变量时，使用int

2. 浮点型：float(4字节) \ double(8字节)

    > ① 浮点型，表示带小数点的数值
    >
    > ② float表示数值的范围比long还大
    >
    > ③ 定义float类型变量时，变量要以"f"或"F"结尾
    >
    > ④ 通常，定义浮点型变量时，使用double型。

3. 字符型：char (1字符=2字节)

   > ① 定义char型变量，通常使用一对'',内部只能写一个字符
   >
   > ② 表示方式：1.声明一个字符 2.转义字符 3.直接使用 Unicode 值来表示字符型常量

4.布尔型：boolean

		> ① 只能取两个值之一：true 、 false
		>
		> ② 常常在条件判断、循环结构中使用

二、变量在类中声明的位置：
		成员变量  vs  局部变量

## 基本数据类型之间的运算规则：

前提：这里讨论只是7种基本数据类型变量间的运算。不包含boolean类型的。

1. 自动类型提升：
    结论：当容量小的数据类型的变量与容量大的数据类型的变量做运算时，结果自动提升为容量大的数据类型。
	byte 、char 、short --> int --> long --> float --> double 

	特别的：当byte、char、short三种类型的变量做运算时，结果为int型
	
2. 强制类型转换：见VariableTest3.java


说明：此时的容量大小指的是，表示数的范围的大和小。比如：float容量要大于long的容量

## 强制类型转换：自动类型提升运算的逆运算。

1.需要使用强转符：()
2.注意点：强制类型转换，可能导致精度损失。

## 运算符

###  运算符之六：三元运算符

1. 结构：(条件表达式)? 表达式1 : 表达式2

2. 说明
① 条件表达式的结果为boolean类型
② 根据条件表达式真或假，决定执行表达式1，还是表达式2.
    如果表达式为true，则执行表达式1。
    如果表达式为false，则执行表达式2。
③ 表达式1 和表达式2要求是一致的。
④ 三元运算符可以嵌套使用
3.  凡是可以使用三元运算符的地方，都可以改写为if-else反之，不成立。
4.  如果程序既可以使用三元运算符，又可以使用if-else结构，那么优先选择三元运算符。原因：简洁、执行效率高。

### 运算符之四：逻辑运算符

&  && |  || ! ^

说明：
1.逻辑运算符操作的都是boolean类型的变量

# 数组

## 概念

数组相关的概念：

数组名

元素

角标、下标、索引

数组的长度：元素的个数

## 初始化

### 1. 一维数组的声明和初始化

	> 1.1静态初始化:数组的初始化和数组元素的赋值操作同时进行
	>
	> 1.2动态初始化:数组的初始化和数组元素的赋值操作分开进行
	>
	> 总结：数组一旦初始化完成，其长度就确定了。

### 2.如何调用数组的指定位置的元素:通过角标的方式调用。

​	数组的角标（或索引）从0开始的，到数组的长度-1结束。

### 3.如何获取数组的长度。

属性:length

### 4.如何遍历数组

for循环

### 5.数组元素的默认初始化值

		> 数组元素是整型：0
		>
		> 数组元素是浮点型：0.0
		>
		> 数组元素是char型：0或'\u0000'，而非'0'
		>
		> 数组元素是boolean型：false
		>
		> 数组元素是引用数据类型：null



## 多维数组

1. 规定：二维数组分为外层数组的元素，内层数组的元素

   > int[][] arr = new int[4][3];
   >  * 		外层元素：arr[0],arr[1]等
   >  * 		内层元素：arr[0][0],arr[1][2]等

2. 数组元素的默认初始化值 

   > 针对于初始化方式一：比如：int[][] arr = new int[4][3];
   >
   > > 外层元素的初始化值为：地址值
   > >
   > > 内层元素的初始化值为：与一维数组初始化情况相同	

   > 针对于初始化方式二：比如：int[][] arr = new int[4][];
   >
   > > 层元素的初始化值为：null
   > >
   > > 内层元素的初始化值为：不能调用，否则报错。

__java.util.Arrays:操作数组的工具类，里面定义了很多操作数组的方法__

# oop

### 面向对象的两个要素：

1. 类：对一类事物的描述，是抽象的、概念上的定义

2. 对象：是实际存在的该类事物的每个个体，因而也称为实例(instance)

   面向对象程序设计的重点是类的设计

   设计类，就是设计类的成员。

### 类中方法的声明和使用

 方法：描述类应该具有的功能。

 比如：Math类：sqrt()\random() \...

   Scanner类：nextXxx() ...

   Arrays类：sort() \ binarySearch() \ toString() \ equals() \ ...

1. 举例：

 public void eat(){}

 public void sleep(int hour){}

 public String getName(){}

 public String getNation(String nation){}

2. 方法的声明：权限修饰符 返回值类型 方法名(形参列表){

​                 方法体

​           }

  注意：static、final、abstract 来修饰的方法，后面再讲。

3. 说明：

​       3.1  关于权限修饰符：默认方法的权限修饰符先都使用public

​          Java规定的4种权限修饰符：private、public、缺省、protected -->封装性再细说

​       3.2  返回值类型： 有返回值 vs 没有返回值

​          3.2.1   如果方法有返回值，则必须在方法声明时，指定返回值的类型。同时，方法中，需要使用

​         return关键字来返回指定类型的变量或常量：“return 数据”。

​               如果方法没有返回值，则方法声明时，使用void来表示。通常，没有返回值的方法中，就不需要

​        使用return.但是，如果使用的话，只能“return;”表示结束此方法的意思。

​          3.2.2  我们定义方法该不该有返回值？

​              ① 题目要求

​              ② 凭经验：具体问题具体分析

​    3.3  方法名：属于标识符，遵循标识符的规则和规范，“见名知意” 

​    3.4  形参列表： 方法可以声明0个，1个，或多个形参。

​     3.4.1  格式：数据类型1 形参1,数据类型2 形参2,...

   3.4.2   我们定义方法时，该不该定义形参？

​           ① 题目要求

​           ② 凭经验：具体问题具体分

​    3.5 方法体：方法功能的体现。     

4.  return关键字的使用：

   1.使用范围：使用在方法体中

   2.作用：① 结束方法

​       ② 针对于有返回值类型的方法，使用"return 数据"方法返回所要的数据。

​        3.注意点：return关键字后面不可以声明执行语句。

5.  方法的使用中，可以调用当前类的属性或方法

​       特殊的：方法A中又调用了方法A:递归方法。

​       方法中，不可以定义方法。

#### 方法的形参的传递机制：值传递

1. 形参：方法定义时，声明的小括号内的参数

   实参：方法调用时，实际传递给形参的数据

2. 值传递机制：

   > 如果参数是基本数据类型，此时实参赋给形参的是实参真实存储的数据值。

   > 如果参数是引用数据类型，此时实参赋给形参的是实参存储数据的地址值。

#### 方法的重载（overload）  loading...

1. 定义：在同一个类中，允许存在一个以上的同名方法，只要它们的参数个数或者参数类型不同即可。

   > "两同一不同":同一个类、相同方法名

   > 参数列表不同：参数个数不同，参数类型不同

2. 举例：

   Arrays类中重载的sort() / binarySearch()

3. 判断是否是重载：

​		跟方法的权限修饰符、返回值类型、形参变量名、方法体都没有关系！

4. 在通过对象调用方法时，如何确定某一个指定的方法：

   方法名 ---> 参数列表

#### 可变个数形参的方法

1. jdk 5.0新增的内容

2. 具体使用：

   2.1 可变个数形参的格式：数据类型 ... 变量名

   2.2 当调用可变个数形参的方法时，传入的参数个数可以是：0个，1个,2个，。。。

   2.3 可变个数形参的方法与本类中方法名相同，形参不同的方法之间构成重载

   2.4 可变个数形参的方法与本类中方法名相同，形参类型也相同的数组之间不构成重载。换句话		说，二者不能共存。

   2.5 可变个数形参在方法的形参中，必须声明在末尾

   2.6 可变个数形参在方法的形参中,最多只能声明一个可变形参。

递归函数：条件达成之后的return是最后一步调用方法的结果；

### 类中属性的使用

属性（成员变量）   vs  局部变量

1. 相同点：
   1. 定义变量的格式：数据类型  变量名 = 变量值
   2. 先声明，后使用
   3. 变量都有其对应的作用域 

2.不同点：
1. 在类中声明的位置的不同

   属性：直接定义在类的一对{}内

   局部变量：声明在方法内、方法形参、代码块内、构造器形参、构造器内部的变量

2. 关于权限修饰符的不同

   属性：可以在声明属性时，指明其权限，使用权限修饰符。

   常用的权限修饰符：private、public、缺省、protected  --->封装性

   局部变量：不可以使用权限修饰符。

- 默认初始化值的情况：

  属性：类的属性，根据其类型，都有默认初始化值。

  ​	整型（byte、short、int、long）：0

  ​	浮点型（float、double）：0.0

  ​	字符型（char）：0  （或'\u0000'）

  ​	布尔型（boolean）：false

  ​	引用数据类型（类、数组、接口）：null

  ​	局部变量：没有默认初始化值。

  ​	意味着，我们在调用局部变量之前，一定要显式赋值。

  特别地：形参在调用时，我们赋值即可。

4. 在内存中加载的位置：

   属性：加载到堆空间中   （非static）

   局部变量：加载到栈空间

1019 学到问题：对象要.close()关闭，之前都不严谨没有在意过

