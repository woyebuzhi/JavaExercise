# 多线程Thread

测试Thread中的常用方法：

1. start():启动当前线程；调用当前线程的run()

2. run(): 通常需要重写Thread类中的此方法，将创建的线程要执行的操作声明在此方法中

3. currentThread():静态方法，返回执行当前代码的线程

4. getName():获取当前线程的名字

5. setName():设置当前线程的名字

6. yield():释放当前cpu的执行权

7. join():在线程a中调用线程b的join(),此时线程a就进入阻塞状态，直到线程b完全执行完以后，线程a才

   结束阻塞状态。

8. stop():已过时。当执行此方法时，强制结束当前线程。

9. sleep(long millitime):让当前线程“睡眠”指定的millitime毫秒。在指定的millitime毫秒时间内，当前

   线程是阻塞状态。

10. isAlive():判断当前线程是否存活
    

线程的优先级：

1.

MAX_PRIORITY：10

MIN _PRIORITY：1

NORM_PRIORITY：5  -->默认优先级

2.如何获取和设置当前线程的优先级：

getPriority():获取线程的优先级

setPriority(int p):设置线程的优先级
 *

说明：高优先级的线程要抢占低优先级线程cpu的执行权。但是只是从概率上讲，高优先级的线程高概率的情况下

被执行。并不意味着只有当高优先级的线程执行完以后，低优先级的线程才执行。

## 多线程的创建，方式一：继承于Thread类

1. 创建一个继承于Thread类的子类

2. 重写Thread类的run() --> 将此线程执行的操作声明在run()中

3. 创建Thread类的子类的对象

4. 通过此对象调用start()

## 创建多线程的方式二：实现Runnable接口

1. 创建一个实现了Runnable接口的类

2. 实现类去实现Runnable中的抽象方法：run()

3. 创建实现类的对象

4. 将此对象作为参数传递到Thread类的构造器中，创建Thread类的对象（通过Thread类的对象调用start():① 启动线程 ②调用当前线程的run()-->调用了Runnable类型的target的run()）

5. 通过Thread类的对象调用start()


比较创建线程的两种方式。

开发中：优先选择：实现Runnable接口的方式

原因：1. 实现的方式没有类的单继承性的局限性

​			2. 实现的方式更适合来处理多个线程有共享数据的情况。


联系：public class Thread implements Runnable

相同点：两种方式都需要重写run(),将线程要执行的逻辑声明在run()中。

### 在Java中，我们通过同步机制，来解决线程的安全问题。
**方式一：同步代码块**

synchronized(同步监视器){

//需要被同步的代

}

说明：1. 操作共享数据的代码，即为需要被同步的代码。  -->不能包含代码多了，也不能包含代码少了。

​			2. 共享数据：多个线程共同操作的变量。比如：ticket就是共享数据。

​			3. 同步监视器，俗称：锁。任何一个类的对象，都可以充当锁。

​		要求：多个线程必须要共用同一把锁。

补充：在实现Runnable接口创建多线程的方式中，我们可以考虑使用this充当同步监视器。

**方式二：同步方法。**

如果操作共享数据的代码完整的声明在一个方法中，我们不妨将此方法声明同步的。

5.同步的方式，解决了线程的安全问题。---好处

操作同步代码时，只能有一个线程参与，其他线程等待。相当于是一个单线程的过程，效率低。 ---局限性

使用同步方法解决实现Runnable接口的线程安全问题

**关于同步方法的总结：**

1. 同步方法仍然涉及到同步监视器，只是不需要我们显式的声明。

2. 非静态的同步方法，同步监视器是：this

   静态的同步方法，同步监视器是：当前类本身

## 创建线程的方式三：实现Callable接口。 --- JDK 5.0新增

1. 如何理解实现Callable接口的方式创建多线程比实现Runnable接口创建多线程方式强大？

   1. call()可以有返回值的。

   2. call()可以抛出异常，被外面的操作捕获，获取异常的信息3. 
   3. Callable是支持泛型的

##  创建线程的方式四：使用线程池 

好处：

1.提高响应速度（减少了创建新线程的时间）

2.降低资源消耗（重复利用线程池中线程，不需要每次都创建）

3.便于线程管理

corePoolSize：核心池的大小

maximumPoolSize：最大线程数

keepAliveTime：线程没有任务时最多保持多长时间后会终止