# 面向对象特征

## 封装性

面向对象的特征一：封装与隐藏     3W:what? why? how?

1. 封装性的体现：

   我们将类的属性xxx私有化(private),同时，提供公共的(public)方法来获取(getXxx)和设置(setXxx)此属性的值

   拓展：封装性的体现：① 如上  ② 不对外暴露的私有的方法  ③ 单例模式   ...

2. 封装性的体现，需要权限修饰符来配合。

   1. Java规定的4种权限（从小到大排列）：private、缺省、protected 、public 

   2. 4种权限可以用来修饰类及类的内部结构：属性、方法、构造器、内部类

   3. 具体的，4种权限都可以用来修饰类的内部结构：属性、方法、构造器、内部类

      修饰类的话，只能使用：缺省、public

3. 总结封装性：Java提供了4种权限修饰符来修饰类及类的内部结构，体现类及类的内部结构在被调用时的可见性的大小。

## 继承性

1. 继承性的好处：

   ① 减少了代码的冗余，提高了代码的复用性

   ② 便于功能的扩展

   ③ 为之后多态性的使用，提供了前提

2. 继承性的格式： 

   _class A extends B{}_

   _A:子类、派生类、subclass_

   _B:父类、超类、基类、superclass_

   1. 体现：一旦子类A继承父类B以后，子类A中就获取了父类B中声明的所有的属性和方法。

      特别的，父类中声明为private的属性或方法，子类继承父类以后，仍然认为获取了父类中私有的结构。

      只有因为封装性的影响，使得子类不能直接调用父类的结构而已。

   2. 子类继承父类以后，还可以声明自己特有的属性或方法：实现功能的拓展。

      ​	子类和父类的关系，不同于子集和集合的关系。

      ​	extends：延展、扩展

3. Java中关于继承性的规定：

   1. 一个类可以被多个子类继承。

   2. Java中类的单继承性：一个类只能有一个父类

   3. 子父类是相对的概念。

   4. 子类直接继承的父类，称为：直接父类。间接继承的父类称为：间接父类

   5. 子类继承父类以后，就获取了直接父类以及所有间接父类中声明的属性和方法

4. 如果我们没有显式的声明一个类的父类的话，则此类继承于java.lang.Object类
   1. 所有的java类（除java.lang.Object类之外）都直接或间接的继承于java.lang.Object类
   2. 意味着，所有的java类具有java.lang.Object类声明的功能。

## 多态性



1. 理解多态性：可以理解为一个事物的多种形态。

2. 何为多态性：

   对象的多态性：父类的引用指向子类的对象（或子类的对象赋给父类的引用）

3. 多态的使用：虚拟方法调用

   有了对象的多态性以后，我们在编译期，只能调用父类中声明的方法，但在运行期，我们实际执行的是子类重写父类的方法。

**总结：编译，看左边；运行，看右边。**

4. 多态性的使用前提：  ① 类的继承关系  ② 方法的重写

5. 对象的多态性，只适用于方法，不适用于属性（编译和运行都看左边）

   1. > 若子类重写了父类方法，就意味着子类里定义的方法彻底覆盖了父类里的同名方法，

      > 系统将不可能把父类里的方法转移到子类中：编译看左边，运行看右边

   2. > 对于实例变量则不存在这样的现象，即使子类里定义了与父类完全相同的实例变量，

      > 这个实例变量依然不可能覆盖父类中定义的实例变量：编译运行都看左边

6. **子类可看做是特殊的父类，所以父类类型的引用可以指向子类的对象：向 上转型(upcasting)。**

7. 一个引用类型变量如果声明为父类的类型，但实际引用的是子类 对象，那么该变量就不能再访问子类中添加的属性和方法

   1. **不能访问的是————不是重写父类的方法**

### 虚拟方法

1. 子类中定义了与父类同名同参数的方法，在多态情况下，将此时父类的方法称为虚拟方法，父 类根据赋给它的不同子类对象，动态调用属于子类的该方法。这样的方法调用在编译期是无法 确定的。
2. 编译和运行时类型
   1. 编译时e为Person类型，而方法的调用是在运行时确定的，所以调用的是Student类 的getInfo()方法。——动态绑定