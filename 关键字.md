# 关键字

## this

1. this可以用来修饰、调用：属性、方法、构造器

2. this修饰属性和方法：

    *   this理解为：当前对象  或 当前正在创建的对象

   1. 在类的方法中，我们可以使用"this.属性"或"this.方法"的方式，调用当前对象属性或方法。但是，
      *  通常情况下，我们都选择省略"this."。特殊情况下，如果方法的形参和类的属性同名时，我们必须显式的使用"this.变量"的方式，表明此变量是属性，而非形参。
   2. 在类的构造器中，我们可以使用"this.属性"或"this.方法"的方式，调用当前正在创建的对象属性或方法。
      * 但是，通常情况下，我们都选择省略"this."。特殊情况下，如果构造器的形参和类的属性同名时，我们必须显式的使用"this.变量"的方式，表明此变量是属性，而非形参。

3. this调用构造器

   * ①我们在类的构造器中，可以显式的使用"this(形参列表)"方式，调用本类中指定的其他构造器

    *    ② 构造器中不能通过"this(形参列表)"方式调用自己
    *    ③ 如果一个类中有n个构造器，则最多有 n - 1构造器中使用了"this(形参列表)"
    *    ④ 规定："this(形参列表)"必须声明在当前构造器的首行
    *    ⑤ 构造器内部，最多只能声明一个"this(形参列表)"，用来调用其他的构造器

## package

1. 为了更好的实现项目中类的管理，提供包的概念

2. 使用package声明类或接口所属的包，声明在源文件的首行

3. 包，属于标识符，遵循标识符的命名规则、规范(xxxyyyzzz)、“见名知意”

4. 每"."一次，就代表一层文件目录。
   * 补充：同一个包下，不能命名同名的接口、类。
   * 不同的包下，可以命名同名的接口、类。

## import

1. 在源文件中显式的使用import结构导入指定包下的类、接口
2. 声明在包的声明和类的声明之间
3. 如果需要导入多个结构，则并列写出即可
4. 可以使用"xxx.*"的方式，表示可以导入xxx包下的所有结构
5. 如果使用的类或接口是java.lang包下定义的，则可以省略import结构
6. 如果使用的类或接口是本包下定义的，则可以省略import结构
7. **如果在源文件中，使用了不同包下的同名的类，则必须至少有一个类需要以全类名的方式显示。**
8. 使用"xxx.*"方式表明可以调用xxx包下的所有结构。但是如果使用的是xxx子包下的结构，则仍需要显式导入
9. import static:导入指定类或接口中的静态结构:属性或方法。

## super

super关键字的使用

1. super理解为：父类的

2. super可以用来调用：属性、方法、构造器

3. super的使用：调用属性和方法

   3.1 我们可以在子类的方法或构造器中。通过使用"super.属性"或"super.方法"的方式，显式的调用父类中声明的属性或方法。但是，通常情况下，我们习惯省略"super."

   3.2  特殊情况：当子类和父类中定义了同名的属性时，我们要想在子类中调用父类中声明的属性，则必须显式的使用"super.属性"的方式，表明调用的是父类中声明的属性。

   3.3 特殊情况：当子类重写了父类中的方法以后，我们想在子类的方法中调用父类中被重写的方法时，则必须显式的使用"super.方法"的方式，表明调用的是父类中被重写的方法。

4. super调用构造器

   4.1  我们可以在子类的构造器中显式的使用"super(形参列表)"的方式，调用父类中声明的指定的构造器

   4.2 "super(形参列表)"的使用，必须声明在子类构造器的首行！

   4.3 我们在类的构造器中，针对于"this(形参列表)"或"super(形参列表)"只能二选一，不能同时出现

   4.4 在构造器的首行，没有显式的声明"this(形参列表)"或"super(形参列表)"，则默认调用的是父类中空参的构造器：super()

   4.5 在类的多个构造器中，至少有一个类的构造器中使用了"super(形参列表)"，调用父类中的构造器



