# 关键字

## this

1. this可以用来修饰、调用：属性、方法、构造器

2. this修饰属性和方法：

    *   this理解为：当前对象  或 当前正在创建的对象

   1. 在类的方法中，我们可以使用"this.属性"或"this.方法"的方式，调用当前对象属性或方法。但是，
      *  通常情况下，我们都选择省略"this."。特殊情况下，如果方法的形参和类的属性同名时，我们必须显式的使用"this.变量"的方式，表明此变量是属性，而非形参。
   2. 在类的构造器中，我们可以使用"this.属性"或"this.方法"的方式，调用当前正在创建的对象属性或方法。
      * 但是，通常情况下，我们都选择省略"this."。特殊情况下，如果构造器的形参和类的属性同名时，我们必须显式的使用"this.变量"的方式，表明此变量是属性，而非形参。

3. this调用构造器

   * ①我们在类的构造器中，可以显式的使用"this(形参列表)"方式，调用本类中指定的其他构造器

    *    ② 构造器中不能通过"this(形参列表)"方式调用自己
    *    ③ 如果一个类中有n个构造器，则最多有 n - 1构造器中使用了"this(形参列表)"
    *    ④ 规定："this(形参列表)"必须声明在当前构造器的首行
    *    ⑤ 构造器内部，最多只能声明一个"this(形参列表)"，用来调用其他的构造器

## package

1. 为了更好的实现项目中类的管理，提供包的概念

2. 使用package声明类或接口所属的包，声明在源文件的首行

3. 包，属于标识符，遵循标识符的命名规则、规范(xxxyyyzzz)、“见名知意”

4. 每"."一次，就代表一层文件目录。
   * 补充：同一个包下，不能命名同名的接口、类。
   * 不同的包下，可以命名同名的接口、类。

## import

1. 在源文件中显式的使用import结构导入指定包下的类、接口
2. 声明在包的声明和类的声明之间
3. 如果需要导入多个结构，则并列写出即可
4. 可以使用"xxx.*"的方式，表示可以导入xxx包下的所有结构
5. 如果使用的类或接口是java.lang包下定义的，则可以省略import结构
6. 如果使用的类或接口是本包下定义的，则可以省略import结构
7. **如果在源文件中，使用了不同包下的同名的类，则必须至少有一个类需要以全类名的方式显示。**
8. 使用"xxx.*"方式表明可以调用xxx包下的所有结构。但是如果使用的是xxx子包下的结构，则仍需要显式导入
9. import static:导入指定类或接口中的静态结构:属性或方法。

## super

super关键字的使用

1. super理解为：父类的

2. super可以用来调用：属性、方法、构造器

3. super的使用：调用属性和方法

   3.1 我们可以在子类的方法或构造器中。通过使用"super.属性"或"super.方法"的方式，显式的调用父类中声明的属性或方法。但是，通常情况下，我们习惯省略"super."

   3.2  特殊情况：当子类和父类中定义了同名的属性时，我们要想在子类中调用父类中声明的属性，则必须显式的使用"super.属性"的方式，表明调用的是父类中声明的属性。

   3.3 特殊情况：当子类重写了父类中的方法以后，我们想在子类的方法中调用父类中被重写的方法时，则必须显式的使用"super.方法"的方式，表明调用的是父类中被重写的方法。

4. super调用构造器

   4.1  我们可以在子类的构造器中显式的使用"super(形参列表)"的方式，调用父类中声明的指定的构造器

   4.2 "super(形参列表)"的使用，必须声明在子类构造器的首行！

   4.3 我们在类的构造器中，针对于"this(形参列表)"或"super(形参列表)"只能二选一，不能同时出现

   4.4 在构造器的首行，没有显式的声明"this(形参列表)"或"super(形参列表)"，则默认调用的是父类中空参的构造器：super()

   4.5 在类的多个构造器中，至少有一个类的构造器中使用了"super(形参列表)"，调用父类中的构造器

## static

1. static:静态的

2. static可以用来修饰：属性、方法、代码块、内部类

3. 使用static修饰属性：静态变量（或类变量）

​	3.1	 属性，按是否使用static修饰，又分为：静态属性  vs 非静态属性(实例变量)

​			实例变量：我们创建了类的多个对象，每个对象都独立的拥有一套类中的非静态属性。当修改			其中一个对象中的

​			非静态属性时，不会导致其他对象中同样的属性值的修改。

​			静态变量：我们创建了类的多个对象，多个对象共享同一个静态变量。当通过某一个对象修改			静态变量时，会导致其他对象调用此静态变量时，是修改过了的。

​	3.2 	static修饰属性的其他说明：

​		① 静态变量随着类的加载而加载。可以通过"类.静态变量"的方式进行调用

​		② 静态变量的加载要早于对象的创建。

​		③ 由于类只会加载一次，则静态变量在内存中也只会存在一份：存在方法区的静态域中。

​		④		类变量	实例变量

​		类		yes		no

​		对象		yes		yes



​	3.3 	静态属性举例：System.out; Math.PI;

4.使用static修饰方法：静态方法

​	① 随着类的加载而加载，可以通过"类.静态方法"的方式进行调用

​	②静态方法	非静态方法

​			类		yes		no

​			对象		yes		yes

​	③ 静态方法中，只能调用静态的方法或属性

​		非静态方法中，既可以调用非静态的方法或属性，也可以调用静态的方法或属性

5. static注意点：

   5.1 在静态的方法内，不能使用this关键字、super关键字

   5.2 关于静态属性和静态方法的使用，大家都从生命周期的角度去理解。

6. 开发中，如何确定一个属性是否要声明为static的？

> 属性是可以被多个对象所共享的，不会随着对象的不同而不同的。

> 类中的常量也常常声明为static

**开发中，如何确定一个方法是否要声明为static的？**

> 操作静态属性的方法，通常设置为static的

> 工具类中的方法，习惯上声明为static的。 比如：Math、Arrays、Collections

## final

final:最终的
1.  final可以用来修饰的结构：类、方法、变量

2. final 用来修饰一个类:此类不能被其他类所继承。

   ​	比如：String类、System类、StringBuffer类

3. final 用来修饰方法：表明此方法不可以被重写

   比如：Object类中getClass();

4.  final 用来修饰变量：此时的"变量"就称为是一个常量

   4.1 final修饰属性：可以考虑赋值的位置有：显式初始化、代码块中初始化、构造器中初始化

   4.2 final修饰局部变量：

   尤其是使用final修饰形参时，表明此形参是一个常量。当我们调用此方法时，给常量形参赋一个实参。一旦赋值以后，就只能在方法体内使用此形参，但不能进行重新赋值。

static final 用来修饰属性：全局常量



## abstract

1. abstract:抽象的

2. abstract可以用来修饰的结构：类、方法

3. abstract修饰类：抽象类
   1. 此类不能实例化
   2. 抽象类中一定有构造器，便于子类实例化时调用（涉及：子类对象实例化的全过程）
   3. 开发中，都会提供抽象类的子类，让子类对象实例化，完成相关的操作

4. abstract修饰方法：抽象方法
   1. 抽象方法只有方法的声明，没有方法体
   2. 包含抽象方法的类，一定是一个抽象类。反之，抽象类中可以没有抽象方法的。
   3. 若子类重写了父类中的所有的抽象方法后，此子类方可实例化

若子类没有重写父类中的所有的抽象方法，则此子类也是一个抽象类，需要使用abstract修饰

5. ***abstract使用上的注意点：***
    * 1.abstract不能用来修饰：属性、构造器等结构
    * 2.abstract不能用来修饰私有方法、静态方法、final的方法、final的类





